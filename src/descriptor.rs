use serde::{Deserialize, Serialize};

use std::collections::HashMap;
use std::error::Error;
use std::fmt;
use std::fs::{self, OpenOptions};
use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::str;

/// The name of the experiment manifest file.
const MANIFEST: &str = "deployment.toml";
/// By default, will log files be generated by clients from their standard output and standard
/// error.
const GEN_LOGS_DEFAULT: bool = false;
lazy_static! {
    /// In the event that logs are to be generated and no directory has been specified, this is
    /// where logs will be written to.
    static ref LOG_DIR_DEFAULT: PathBuf = PathBuf::from("logs/");
}

#[derive(Serialize, Deserialize, Default)]
pub struct ExperimentDescriptor {
    name: String,
    command: Option<String>,
    args: Option<Vec<String>>,
    hosts: HashMap<String, HostDescriptor>,
    #[serde(default = "gen_logs_default")]
    gen_logs: bool,
    #[serde(default = "log_dir_default")]
    log_dir: PathBuf,
}

#[derive(Serialize, Deserialize, Default)]
pub struct HostDescriptor {
    command: Option<String>,
    args: Option<Vec<String>>,
}

#[derive(Debug)]
pub struct ExperimentParseError {
    cause: Box<dyn Error>,
}

impl fmt::Display for ExperimentParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "failed to parse experiment descriptor")
    }
}

impl From<Box<dyn Error>> for ExperimentParseError {
    fn from(cause: Box<dyn Error>) -> ExperimentParseError {
        ExperimentParseError { cause }
    }
}

impl Error for ExperimentParseError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&*self.cause)
    }
}

impl str::FromStr for ExperimentDescriptor {
    type Err = ExperimentParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match toml::from_str::<ExperimentDescriptor>(s) {
            Ok(descriptor) => Ok(descriptor),
            Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
        }
    }
}

impl ExperimentDescriptor {
    pub fn load_from<P: AsRef<Path>>(
        path: P,
    ) -> Result<ExperimentDescriptor, ExperimentParseError> {
        match fs::File::open(path.as_ref().join(MANIFEST)) {
            Ok(mut file) => {
                let mut contents = String::new();
                match file.read_to_string(&mut contents) {
                    Ok(_) => contents.parse::<ExperimentDescriptor>(),
                    Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
                }
            }
            Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn log_dir(&self) -> &Path {
        &self.log_dir
    }

    pub fn execute_for<P: AsRef<Path>, Q: AsRef<Path>>(&self, hostname: &str, work_dir: P, log: Q) {
        if let Some(host) = self.hosts.get(hostname) {
            let mut options = OpenOptions::new();
            options.append(true).create(true);
            let log_dir = work_dir.as_ref().join(self.log_dir());
            if self.gen_logs {
                fs::create_dir_all(&log_dir).unwrap_or(());
            }
            let stdout = log_dir.join(&log).with_extension("stdout");
            let stderr = log_dir.join(&log).with_extension("stderr");
            if let Some(ref command) = self.command {
                let mut command = Command::new(command);
                command.current_dir(&work_dir);
                if let Some(ref args) = self.args {
                    for arg in args.iter() {
                        command.arg(arg);
                    }
                }
                if self.gen_logs {
                    command.stdout(Stdio::from(options.open(&stdout).unwrap()));
                    command.stderr(Stdio::from(options.open(&stderr).unwrap()));
                }
                command.output().unwrap();
            }
            if let Some(ref command) = host.command {
                let mut command = Command::new(command);
                command.current_dir(&work_dir);
                if let Some(ref args) = host.args {
                    for arg in args.iter() {
                        command.arg(arg);
                    }
                }
                if self.gen_logs {
                    command.stdout(Stdio::from(options.open(&stdout).unwrap()));
                    command.stderr(Stdio::from(options.open(&stderr).unwrap()));
                }
                command.output().unwrap();
            }
        }
    }
}

/// These are work-around helper functions to avoid the fact that serde does not currently support
/// using constants as defaults.
#[inline]
const fn gen_logs_default() -> bool {
    GEN_LOGS_DEFAULT
}

#[inline]
fn log_dir_default() -> PathBuf {
    LOG_DIR_DEFAULT.to_path_buf()
}
