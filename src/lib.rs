#[macro_use]
extern crate lazy_static;

use serde::{Deserialize, Serialize};

use std::collections::HashMap;
use std::error::Error;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::str;
use std::{fmt, fs};

/// By default, will log files be generated by clients from their standard output and standard
/// error.
const GEN_LOGS_DEFAULT: bool = false;
lazy_static! {
    /// In the event that logs are to be generated and no directory has been specified, this is
    /// where logs will be written to.
    static ref LOG_DIR_DEFAULT: PathBuf = PathBuf::from("logs/");
}

#[derive(Serialize, Deserialize, Default)]
pub struct ExperimentDescriptor {
    name: String,
    command: Option<String>,
    args: Option<Vec<String>>,
    hosts: HashMap<String, HostDescriptor>,
    #[serde(default = "gen_logs_default")]
    gen_logs: bool,
    #[serde(default = "log_dir_default")]
    log_dir: PathBuf,
}

#[derive(Serialize, Deserialize, Default)]
pub struct HostDescriptor {
    command: Option<String>,
    args: Option<Vec<String>>,
}

#[derive(Debug)]
pub struct ExperimentParseError {
    cause: Box<dyn Error>,
}

impl fmt::Display for ExperimentParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "failed to parse experiment descriptor")
    }
}

impl From<Box<dyn Error>> for ExperimentParseError {
    fn from(cause: Box<dyn Error>) -> ExperimentParseError {
        ExperimentParseError { cause }
    }
}

impl Error for ExperimentParseError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&*self.cause)
    }
}

impl str::FromStr for ExperimentDescriptor {
    type Err = ExperimentParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match toml::from_str::<ExperimentDescriptor>(s) {
            Ok(descriptor) => Ok(descriptor),
            Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
        }
    }
}

impl ExperimentDescriptor {
    pub fn load_from<P>(path: P) -> Result<ExperimentDescriptor, ExperimentParseError>
    where
        P: AsRef<Path>,
    {
        match fs::File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                match file.read_to_string(&mut contents) {
                    Ok(_) => contents.parse::<ExperimentDescriptor>(),
                    Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
                }
            }
            Err(err) => Err((Box::new(err) as Box<dyn Error>).into()),
        }
    }
}

/// These are work-around helper functions to avoid the fact that serde does not currently support
/// using constants as defaults.
#[doc(hidden)]
#[inline]
const fn gen_logs_default() -> bool {
    GEN_LOGS_DEFAULT
}

#[doc(hidden)]
#[inline]
fn log_dir_default() -> PathBuf {
    LOG_DIR_DEFAULT.to_path_buf()
}
